(() => {
  "use strict";

  /* ---------------------------------------------------------------------------
   * Webtor Embed (lisible + fonctionnel)
   * - window.webtor.push({ magnet: "...", ... })
   * - Auto-remplace <video> et <a download> en embeds Webtor
   * ------------------------------------------------------------------------- */

  // -----------------------------
  // Utilitaires
  // -----------------------------
  function uuidv4() {
    // UUID v4 simple (équivalent au bundle d'origine)
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  function clean(obj) {
    // Supprime null/undefined
    for (const k in obj) {
      if (obj[k] === null || obj[k] === undefined) delete obj[k];
    }
    return obj;
  }

  function parsePath(path) {
    const parts = String(path).replace(/^\//, "").split("/");
    const file = parts.pop();
    return { pwd: "/" + parts.join("/"), file };
  }

  function safeJsonParse(value, fallback) {
    try {
      return JSON.parse(value);
    } catch {
      return fallback;
    }
  }

  // -----------------------------
  // Iframe resizer (repris du bundle, reformaté)
  // -----------------------------
  function iframeResizerCore(userSettings, target) {
    const isBrowser = () => typeof window !== "undefined";
    const isIFrame = (el) => el instanceof HTMLIFrameElement;

    const getOriginFromSrc = (iframe) => {
      try {
        const origin = new URL(iframe.src).origin;
        if (origin !== "about:blank") return origin;
      } catch {}
      return null;
    };

    const stripUndefined = (obj) => {
      Object.keys(obj).forEach((k) => obj[k] === undefined && delete obj[k]);
      return obj;
    };

    const rectSize = (el) => {
      const { height, width } = el.getBoundingClientRect();
      return { height: Math.ceil(height), width: Math.ceil(width) };
    };

    const queryTarget = (doc, selector) => {
      if (!doc) return null;
      return selector ? doc.querySelector(selector) : doc.documentElement;
    };

    const applyBodySpacing = (doc, settings) => {
      if (!doc) return;
      if (settings.bodyPadding) doc.body.style.padding = settings.bodyPadding;
      if (settings.bodyMargin) doc.body.style.margin = settings.bodyMargin;
    };

    const retryBackoff = (attempt) => {
      // même logique que le bundle d'origine
      if (attempt <= 100) return 100;
      if (attempt <= 120) return 1000;
      return 10000;
    };

    let registered = [];

    function computeAllowedOrigins(settings, iframes) {
      if (Array.isArray(settings.checkOrigin)) return settings.checkOrigin;
      if (!settings.checkOrigin) return [];
      const origins = [];
      for (const iframe of iframes) {
        const origin = getOriginFromSrc(iframe);
        if (origin) origins.push(origin);
      }
      return origins;
    }

    function sameOrigin(iframe) {
      try {
        return new URL(iframe.src).origin === window.location.origin;
      } catch {
        return false;
      }
    }

    function resizeToHeight({ registeredElement, newHeight }) {
      const { iframe, settings, interactionState, initContext } = registeredElement;

      if (!initContext.isInitialized) {
        initContext.isInitialized = true;
        clearTimeout(initContext.retryTimeoutId);
      }

      const prevRect = iframe.getBoundingClientRect();
      const heightPx = newHeight + settings.offsetSize;
      iframe.style.height = `${heightPx}px`;

      if (typeof settings.onIframeResize === "function") {
        settings.onIframeResize({
          iframe,
          settings: { ...settings },
          interactionState: { ...interactionState },
          previousRenderState: { rect: prevRect },
          nextRenderState: { rect: iframe.getBoundingClientRect() },
        });
      }
    }

    // ResizeObserver partagé (child-in-doc même origine)
    const sharedRO = (() => {
      let ro = null;
      return () => {
        if (!ro) {
          ro = new ResizeObserver((entries) => {
            for (const entry of entries) {
              const doc = entry.target.ownerDocument;
              const reg = registered.find((x) => x.iframe.contentDocument === doc);
              if (!reg) continue;

              const targetEl = queryTarget(reg.iframe.contentDocument, reg.settings.targetElementSelector);
              if (!targetEl) continue;

              const { height } = rectSize(targetEl);
              if (height) resizeToHeight({ registeredElement: reg, newHeight: height });
            }
          });
        }
        return ro;
      };
    })();

    // ResizeObserver côté "child" (utilisé si on est dans l'iframe et que la page supporte le protocole)
    const childRO = (() => {
      let ro = null;
      return () => {
        if (!ro) {
          ro = new ResizeObserver((entries) => {
            if (!entries[0] || !entries[0].target) return;
            const { height, width } = rectSize(entries[0].target);
            window.parent.postMessage({ type: "iframe-resized", width, height }, "*");
          });
        }
        return ro;
      };
    })();

    // Init côté iframe "child" (si ce script tournait dans l’iframe)
    // Ici, on laisse la logique (comme dans le bundle), sans l’activer côté parent.
    let childInitialized = false;
    function initChildHandshake(messageEvent, attempt = 0) {
      const data = messageEvent.data;
      const targetSelector = data.targetElementSelector;
      const bodyPadding = data.bodyPadding;
      const bodyMargin = data.bodyMargin;

      const el = queryTarget(document, targetSelector);
      if (childInitialized || window.parent !== messageEvent.source) return;
      if (!el) return setTimeout(() => initChildHandshake(messageEvent, attempt + 1), retryBackoff(attempt));

      applyBodySpacing(document, { bodyPadding, bodyMargin });
      const ro = childRO();
      ro.disconnect();
      ro.observe(el);

      childInitialized = true;
    }

    if (isBrowser() && window.self !== window.top) {
      window.addEventListener("message", (e) => {
        if (e?.data?.type === "iframe-child-init") {
          const run = () => initChildHandshake(e);
          if (document.readyState === "complete") run();
          else window.addEventListener("load", run, { once: true });
        }
      });
    }

    // Parent setup
    if (!isBrowser()) return [];

    const settings = {
      offsetSize: 0,
      checkOrigin: true,
      enableLegacyLibSupport: false,
      ...stripUndefined(userSettings ?? {}),
    };

    const iframes = (() => {
      if (typeof target === "string") {
        return Array.from(document.querySelectorAll(target)).filter(isIFrame);
      }
      if (target) {
        if (isIFrame(target)) return [target];
        return [];
      }
      return Array.from(document.getElementsByTagName("iframe"));
    })();

    const allowedOrigins = computeAllowedOrigins(settings, iframes);

    function bindHoverState({ iframe, interactionState }) {
      const onEnter = () => (interactionState.isHovered = true);
      const onLeave = () => (interactionState.isHovered = false);

      iframe.addEventListener("mouseenter", onEnter);
      iframe.addEventListener("mouseleave", onLeave);

      return () => {
        iframe.removeEventListener("mouseenter", onEnter);
        iframe.removeEventListener("mouseleave", onLeave);
      };
    }

    function setupOne(iframe) {
      const entry = {
        iframe,
        settings,
        interactionState: { isHovered: false },
        initContext: { isInitialized: false, retryAttempts: 0, retryTimeoutId: undefined },
      };

      // même origine → on peut mesurer le DOM interne
      const unsubscribeResize =
        sameOrigin(entry.iframe)
          ? (() => {
              const { iframe, settings } = entry;
              const { targetElementSelector } = settings;
              let attempt = 0;

              const poll = () => {
                const targetEl = queryTarget(iframe.contentDocument, targetElementSelector);
                if (!iframe.contentDocument || !targetEl) {
                  attempt++;
                  setTimeout(poll, retryBackoff(attempt));
                  return;
                }
                applyBodySpacing(iframe.contentDocument, settings);
                sharedRO().observe(targetEl);
              };

              const onLoad = () => poll();
              if (iframe.contentWindow && iframe.contentWindow.document?.readyState === "complete") {
                onLoad();
              } else {
                iframe.addEventListener("load", onLoad);
              }

              return () => {
                const targetEl = queryTarget(iframe.contentDocument, targetElementSelector);
                if (targetEl) sharedRO().unobserve(targetEl);
                iframe.removeEventListener("load", onLoad);
              };
            })()
          : (() => {
              // cross-origin → protocole postMessage
              const { iframe, initContext, settings } = entry;
              const {
                checkOrigin,
                enableLegacyLibSupport,
                targetElementSelector,
                bodyPadding,
                bodyMargin,
              } = settings;

              const onMessage = (ev) => {
                const okOrigin =
                  !checkOrigin ||
                  allowedOrigins.includes(ev.origin);

                if (iframe.contentWindow !== ev.source || !okOrigin) return;

                // nouveau protocole
                if (ev?.data?.type === "iframe-resized") {
                  const { height } = ev.data;
                  if (height) resizeToHeight({ registeredElement: entry, newHeight: height });
                  return;
                }

                // support legacy iFrameSizer (optionnel)
                if (enableLegacyLibSupport && typeof ev.data === "string" && ev.data.startsWith("[iFrameSizer]")) {
                  const parts = ev.data.split(":");
                  const n = +parts[1];
                  if (n > 0) resizeToHeight({ registeredElement: entry, newHeight: n });
                }
              };

              window.addEventListener("message", onMessage);

              const childInitMessage = enableLegacyLibSupport
                ? "[iFrameSizer]ID:0:false:false:32:true:true::auto:::0:false:child:auto:true:::true:::false"
                : {
                    type: "iframe-child-init",
                    targetElementSelector,
                    bodyPadding,
                    bodyMargin,
                  };

              const sendInit = () => {
                const post = () => iframe.contentWindow?.postMessage(childInitMessage, "*");
                post();
                iframe.addEventListener("load", post);

                initContext.retryAttempts++;
                initContext.retryTimeoutId = window.setTimeout(sendInit, retryBackoff(initContext.retryAttempts));
              };

              sendInit();

              return () => {
                window.removeEventListener("message", onMessage);
              };
            })();

      const unsubscribeHover = bindHoverState(entry);

      registered.push(entry);

      return () => {
        unsubscribeResize();
        unsubscribeHover();
        registered = registered.filter((x) => x.iframe !== iframe);
      };
    }

    return iframes.map((iframe) => ({ unsubscribe: setupOne(iframe) }));
  }

  // -----------------------------
  // Webtor Player proxy
  // -----------------------------
  class Player {
    constructor(send) {
      this.send = send;
    }
    play() {
      this.send("play");
    }
    pause() {
      this.send("pause");
    }
    setPosition(seconds) {
      this.send("setPosition", seconds);
    }
    open(path) {
      this.send("open", parsePath(path));
    }
  }

  // -----------------------------
  // Defaults (comme ton bundle)
  // -----------------------------
  const DEFAULTS = {
    baseUrl: "https://webtor.io",
    width: "800px",
    height: null,
    mode: "video",
    subtitles: [],
    poster: null,
    header: true,
    title: null,
    imdbId: null,
    version: "0.2.19",
    lang: null,
    userlang: null,
    i18n: {},
    features: {},
    referer: window.location.href,

    // Sécurité: désactive l'ancienne feature INJECT par défaut
    allowInject: false,
  };

  // -----------------------------
  // WebtorGenerator (API window.webtor)
  // -----------------------------
  class WebtorGenerator {
    constructor() {
      // événements (compat)
      this.TORRENT_FETCHED = "torrent fetched";
      this.TORRENT_ERROR = "torrent error";
      this.INIT = "init";
      this.PLAY_CLICKED = "play_clicked";
      this.OPEN = "open";
      this.INJECT = "inject";
      this.INITED = "inited";
      this.PLAYER_STATUS = "player status";
      this.CURRENT_TIME = "current time";
      this.DURATION = "duration";
      this.OPEN_SUBTITLES = "open subtitles";
    }

    push(data) {
      const id = uuidv4();
      const iframeId = `webtor-${id}`;

      let dd = Object.assign({}, DEFAULTS, data);

      // compat: si on passe "path", on l'explose en {pwd,file}
      if (dd.path) dd = Object.assign(dd, parsePath(dd.path));

      // où injecter l'iframe ?
      let container = null;
      if (dd.el) {
        container = dd.el;
      } else {
        container = document.getElementById(dd.id);
        if (!container) throw new Error(`Failed to find element with id "${dd.id}"`);
      }

      // validation source torrent
      if (dd.torrentUrl && dd.magnet) throw new Error("There should be only one magnet or torrentUrl");
      if (!dd.torrentUrl && !dd.magnet) throw new Error("magnet or torrentUrl required");

      // URL Webtor
      const params = new URLSearchParams({ id, mode: dd.mode });
      const url = `${dd.baseUrl}/show?${params.toString()}`;

      const baseOrigin = (() => {
        try {
          return new URL(dd.baseUrl).origin;
        } catch {
          return null;
        }
      })();

      // création iframe
      const iframe = document.createElement("iframe");
      iframe.id = iframeId;
      if (dd.width) iframe.width = dd.width;
      if (dd.height) iframe.height = dd.height;

      iframe.setAttribute("allowFullScreen", "");
      iframe.setAttribute("webkitAllowFullScreen", "");
      iframe.setAttribute("mozAllowFullScreen", "");
      iframe.scrolling = "no";
      iframe.frameBorder = "0";
      iframe.allow = "accelerometer; autoplay; encrypted-media; gyroscope; fullscreen; picture-in-picture";

      let unsubscribeAutoResize;
      if (!dd.height) {
        iframe.onload = () => {
          // auto-resize si height non fourni
          const sub = iframeResizerCore({}, `#${iframeId}`)[0];
          unsubscribeAutoResize = sub?.unsubscribe;
        };
      }

      container.appendChild(iframe);
      iframe.src = url;

      // Proxy Player
      const player = new Player((name, payload) => {
        const msg = { id, name, data: payload };
        // envoi vers l'origine webtor si possible, sinon fallback "*"
        iframe.contentWindow?.postMessage(msg, baseOrigin || "*");
      });

      // Réception événements depuis l'iframe
      const onMessage = (event) => {
        const d = event.data;
        if (typeof d !== "object" || !d || d.id !== id) return;

        // vérifie l'origine si on peut
        if (baseOrigin && event.origin !== baseOrigin) return;

        d.player = player;

        if (d.name === this.INIT) {
          // renvoie la config à l'iframe
          const cloned = JSON.parse(JSON.stringify(dd));
          iframe.contentWindow?.postMessage({ id, name: "init", data: cloned }, baseOrigin || "*");
          return;
        }

        if (d.name === this.PLAY_CLICKED) {
          if (typeof unsubscribeAutoResize === "function") unsubscribeAutoResize();
          return;
        }

        if (d.name === this.INJECT) {
          // Sécurité: désactivé par défaut
          if (dd.allowInject === true) {
            // ATTENTION: exécute du code distant
            // eslint-disable-next-line no-eval
            eval(d.data);
          }
          return;
        }

        if (typeof dd.on === "function") {
          dd.on(d);
        }
      };

      window.addEventListener("message", onMessage);
    }
  }

  // -----------------------------
  // Factory window.webtor (compat bundle)
  // -----------------------------
  function createWebtor(existing) {
    if (existing) {
      // compat: si on te donne déjà un tableau de configs
      if (Array.isArray(existing)) {
        const gen = new WebtorGenerator();
        for (const cfg of existing) gen.push(cfg);
        return gen;
      }
      // déjà initialisé → ne touche pas
      return existing;
    }
    return new WebtorGenerator();
  }

  // -----------------------------
  // Auto-embeds: <video> et <a download>
  // -----------------------------
  function makeEmbeds(nodeList, baseDefaults = {}) {
    for (const node of nodeList) {
      let src = node.getAttribute("src") || node.getAttribute("href");

      let magnet = null;
      let torrentUrl = null;

      if (src && /^magnet:/.test(src)) magnet = src;

      // .torrent ou type bittorrent
      const isTorrent =
        (src && /\.torrent(\?.*)?$/i.test(src)) ||
        node.getAttribute("type") === "application/x-bittorrent";

      if (isTorrent) torrentUrl = src;

      // attribut data-torrent prioritaire
      if (node.getAttribute("data-torrent")) torrentUrl = node.getAttribute("data-torrent");

      const parent = node.parentNode;
      if (!parent) continue;

      const width = node.getAttribute("width");
      const height = node.getAttribute("height");
      const poster = node.getAttribute("poster");

      const controls =
        node.getAttribute("controls") === "" || node.getAttribute("controls") === "true";

      // récupère tous les data-* (sauf data-config)
      const dataAttrs = {};
      for (const attr of node.attributes) {
        if (attr.name === "data-config") continue;
        if (attr.name.startsWith("data-")) {
          const key = attr.name.replace("data-", "");
          const parsed = safeJsonParse(attr.value, attr.value);
          dataAttrs[key] = parsed;
        }
      }

      // tracks -> subtitles
      const subtitles = [];
      for (const tr of node.querySelectorAll("track")) {
        subtitles.push(
          clean({
            srclang: tr.getAttribute("srclang"),
            label: tr.getAttribute("label"),
            default: tr.getAttribute("default"),
            src: tr.getAttribute("src"),
          })
        );
      }
      if (subtitles.length > 0) dataAttrs.subtitles = subtitles;

      // data-config JSON
      const configJson = node.getAttribute("data-config");
      const config = configJson ? safeJsonParse(configJson, {}) : {};

      // div de remplacement
      const host = document.createElement("div");
      if (node.getAttribute("class")) host.setAttribute("class", node.getAttribute("class"));
      if (node.getAttribute("id")) host.setAttribute("id", node.getAttribute("id"));

      // config finale
      let finalCfg = {
        el: host,
        magnet,
        torrentUrl,
        width,
        height,
        poster,
        controls,
      };

      finalCfg = Object.assign(
        {},
        baseDefaults,
        clean(finalCfg),
        dataAttrs,
        config
      );

      // remplace dans le DOM + push
      parent.replaceChild(host, node);
      window.webtor.push(clean(finalCfg));
    }
  }

  // -----------------------------
  // Boot
  // -----------------------------
  window.webtor = createWebtor(window.webtor);

  // Auto: remplace <video> (mode video)
  makeEmbeds(document.querySelectorAll("video"));

  // Auto: remplace <a download> (mode download)
  makeEmbeds(document.querySelectorAll("a[download]"), { mode: "download", width: "400px" });

})();
